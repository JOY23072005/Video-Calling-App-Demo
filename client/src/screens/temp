import React,{useEffect,useState,useRef} from 'react'
import { useSocket } from '../context/SocketProvider'
import { useCallback } from 'react';
import peer from '../service/peer';

export default function Room() {
    const socket = useSocket();
    const [remoteSocketId,setRemoteSocketId] = useState(null);
    const [myStream,setMyStream] = useState(null);
    const [remoteStream,setRemoteStream] = useState(null);
    const videoRef = useRef(null);
    const videoRef2 = useRef(null);
    const myStreamRef = useRef(null);

    const handleUserJoined = useCallback(({email, id})=>{
        console.log(`Email ${email} joined!`)
        setRemoteSocketId(id);
    },[])

    const handleCallUser = useCallback (async()=>{
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio:true,
                video:true
            })
            setMyStream(stream);
            // console.log(myStream);
            // console.log(remoteSocketId);

        } catch (err) {
            console.error("Error accessing camera: ", err);
        }

        const offer = await peer.getOffer();
        socket.emit("user:call",{to: remoteSocketId,offer: offer})

    },[remoteSocketId,socket]);

    const handleIncommingCall = useCallback(async (data)=>{
        // console.log(`incoming call ${offer}`);
        const {from , offer} = data;
        console.log(`incoming call ${from,offer}`);
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio:true,
                video:true
            })
            setMyStream(stream);
        } catch (err) {
            console.error("Error accessing camera: ", err);
        }

        const ans = await peer.getAnswer(offer);
        socket.emit('call:accepted',{to:from,ans:ans});

    },[])

    const handleCallAccepted = useCallback((data) => {
        // console.log(data);
        const {from,ans}=data;
        peer.setLocalDescription(ans);
        console.log("Call Accepted!");
        // peer.peer.addTrack()
        const stream = myStreamRef.current;
        if (!stream) {
            console.warn("myStream not ready when call accepted.");
            return;
        }

        for (const track of stream.getTracks()) {
            peer.peer.addTrack(track, stream);
        }
    },[]);

    useEffect(()=>{
        peer.peer.addEventListener('track',async ev => {
            const remoteStream = ev.streams
            setRemoteStream(remoteStream);
        });
        return ()=>{
            peer.peer.removeEventListener('track',async ev => {
                const remoteStream = ev.streams
                setRemoteStream(remoteStream);
            });
        }
    },[])

    const handleNegoNeeded = useCallback(async () =>{
            const offer = await peer.getOffer();
            socket.emit('peer:nego:needed',{offer:offer,to: remoteSocketId})
        },[socket])
    const handleNegoNeedIn = useCallback(({from,offer}) =>{
            const ans = peer.getAnswer(offer);
            socket.emit('peer:nego:done',{to: from, ans:ans});
        },[socket])
    const handleNegoFinal = useCallback(async({from,ans}) =>{
            await peer.setLocalDescription(ans)
        },[peer])

    useEffect(()=>{
        peer.peer.addEventListener('negotiationneeded',handleNegoNeeded);
        return ()=>{
            peer.peer.removeEventListener('negotiationneeded',handleNegoNeeded);
        }
    },[handleNegoNeeded]);

    useEffect(()=>{
        socket.on('user:joined',handleUserJoined);
        socket.on('incomming:call',handleIncommingCall);
        socket.on("call:accepted",handleCallAccepted);
        socket.on("peer:nego:needed",handleNegoNeedIn);
        socket.on("peer:nego:final",handleNegoFinal);
        return ()=>{
            socket.off('user:joined',handleUserJoined);
            socket.off('incomming:call',handleIncommingCall);
            socket.off("call:accepted",handleCallAccepted);
            socket.off("peer:nego:needed",handleNegoNeedIn);
            socket.off("peer:nego:final",handleNegoFinal);
        }
    },[socket])
    useEffect(()=>{
        if (videoRef.current) {
                videoRef.current.srcObject = myStream;
            }
        if (myStream) {
            myStreamRef.current = myStream;
        }
    },[myStream])
    useEffect(()=>{
        if (videoRef2.current) {
                videoRef2.current.srcObject = remoteStream;
            }
    },[remoteStream])
  return (
    <div>
      <h1>Room Page</h1>
      <h4>{remoteSocketId?"You Are Connected":"No One in the Room"}</h4>
      {remoteSocketId && <button onClick={handleCallUser}>Call</button>}
      <div style={{display:"flex"}}>
        { myStream &&
      <div>
      <h4>My Stream</h4>
      <video
        ref={videoRef}
        autoPlay
        playsInline
        width="200"
        height="100"
        muted
      />
      </div>
      }
      {remoteStream && 
      <div>
      <h4>Remote Stream</h4>
      <video
        ref={videoRef2}
        autoPlay
        playsInline
        width="200"
        height="100"
        muted
      />
      </div>
      }
      </div>
    </div>
  )
}
